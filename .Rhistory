x <- (x + alpha)^lambda/lambda - 1
} else {
x <- log(x + alpha)
}
}
storage.mode(x) <- "double"
return(
.C(
"LGTr_C",
x,
nrow(x),
ncol(x),
method
)[[1L]]
)
}
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chord",lambda=1,a=1) -> chord2
##
plot(x=dist(chord),y=dist(chord2),asp=1)
abline(0,1)
LGTransforms(x,"chord",lambda=0,a=1) -> chord2
##
plot(x=dist(chord),y=dist(chord2),asp=1)
abline(0,1)
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chord",lambda=0,a=1) -> chord2
rm(list=ls())
library(codep)
##
data(Doubs)
##
data(Doubs)
## Removing any species that have not been not observed:
Doubs.fish -> x
x[rowSums(x)!=0,] -> x
## **************************************************************************
##
##    (c) 2018-2022 Guillaume Guénard
##        Department de sciences biologiques,
##        Université de Montréal
##        Montreal, QC, Canada
##
##    **Legendre and Gallagher transformation function**
##
##    This file is part of codep
##
##    codep is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    codep is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with codep. If not, see <https://www.gnu.org/licenses/>.
##
##    R source code file
##
## **************************************************************************
##
#' Transformation for Species Abundance Data
#'
#' Calculates the transformed species abundances following Legendre and
#' Gallagher.
#'
#' @param x A species abundance matrix (rows: sites, columns: species).
#' @param method The transformation method, one of chord (the default), chisq,
#' profile, Hellinger (see details).
#' @param lambda Exponent for the Box Cox transformation to be applied before
#' applying further transformation (defaut: 1, see Details).
#' @param alpha Offset parameter for the Box Cox transformation to be applied
#' before applying further transformation (defaut: 1, see Details).
#'
#' @return A matrix of the transformed species abundances.
#'
#' @details Multivariate least squares methods for ordination methods, such as
#' the principal component analysis, or modelling methods, such as the
#' multiscale codependence analysis (\code{\link{MCA}}), the canonical
#' redundancy analysis (RDA).
#'
#' The Box Cox transformation involves the following equation:
#'
#' y' = (y + alpha)^lambda/lambda - 1   if lambda != 0
#' y' = log(y + alpha)                  if lambda == 0
#'
#' @author \packageAuthor{codep}
#' Maintainer: \packageMaintainer{codep}
#'
#' @references
#' Legendre, P. & Gallagher E. D. 2001. Ecologically meaningful transformations
#' for ordination of species data. Oecologia 129: 271-280
#' doi: 10.1007/s004420100716
#'
#' @importFrom stats dist
#' @importFrom graphics mtext
#'
#' @examples
#'
#' data(Doubs)
#'
#' ## Removing any species that have not been not observed:
#' Doubs.fish -> x
#' x[rowSums(x)!=0,] -> x
#'
#' ## Transforming the abundances
#' LGTransforms(x,"chord") -> chord
#' LGTransforms(x,"chisq") -> chisq
#' LGTransforms(x,"profile") -> sp_pr
#' LGTransforms(x,"Hellinger") -> Helli
#'
#' dist(chord)
#' dist(chisq)
#' dist(sp_pr)
#' dist(Helli)
#'
#' ## Legendre & Gallagher synthetic examples:
#'
#' data(LGDat)
#'
#' ## Diastemograms:
#'
#' as.matrix(dist(LGDat[,1L])) -> geo
#' geo[upper.tri(geo)] -> geo
#'
#' ## Raw Euclidean distances
#' par(mfrow=c(1,1), mar=c(5,5,4,2))
#'
#' as.matrix(dist(LGDat[,-1L])) -> eco
#' eco[upper.tri(eco)] -> eco
#'
#' plot(eco~geo, data=data.frame(geo=geo, eco=eco),
#'      xaxp=c(1,18,17), las=1, ylim=c(0,max(eco)),
#'      xlab="True geographic distance",
#'      ylab="Euclidean distance")
#'
#' ## Euclidean distances on the transformed abundances:
#' par(mfrow=c(2,2), mar=c(5,5,4,2))
#'
#' LGTransforms(LGDat[,-1L],"chord") -> chord
#' as.matrix(dist(chord)) -> eco
#' eco[upper.tri(eco)] -> eco
#' plot(eco~geo,data=data.frame(geo=geo,eco=eco),
#'      xaxp=c(1,18,17),las=1,xlab="",ylab="",
#'      main="Chord distance",ylim=c(0,max(eco)))
#'
#' LGTransforms(LGDat[,-1L],"chisq") -> chisq
#' as.matrix(dist(chisq)) -> eco
#' eco[upper.tri(eco)] -> eco
#' plot(eco~geo,data=data.frame(geo=geo,eco=eco),
#'      xaxp=c(1,18,17),las=1,xlab="",ylab="",
#'      main="Chi-square distance",ylim=c(0,max(eco)))
#'
#' LGTransforms(LGDat[,-1L],"profile") -> sp_pr
#' as.matrix(dist(sp_pr)) -> eco
#' eco[upper.tri(eco)] -> eco
#' plot(eco~geo,data=data.frame(geo=geo,eco=eco),
#'      xaxp=c(1,18,17),las=1,xlab="",ylab="",
#'      main="Dist. between profiles",ylim=c(0,max(eco)))
#'
#' LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
#' as.matrix(dist(Helli)) -> eco
#' eco[upper.tri(eco)] -> eco
#' plot(eco~geo,data=data.frame(geo=geo,eco=eco),
#'      xaxp=c(1,18,17),las=1,xlab="",ylab="",
#'      main="Hellinger distance",ylim=c(0,max(eco)))
#'
#' mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
#' mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)
#'
#' @useDynLib codep, .registration = TRUE
#'
#' @export
LGTransforms <- function(x, method = c("chord","chisq","profile","Hellinger"),
lambda = 1, alpha = 1) {
method <- match.arg(method)
method <- match(method, c("chord","chisq","profile","Hellinger"))
if(!is.matrix(x))
x <- as.matrix(x)
if(!((lambda == 1) && (alpha == 1))) {
if(lambda != 0) {
x <- (x + alpha)^lambda/lambda - 1
} else {
x <- log(x + alpha)
}
}
storage.mode(x) <- "double"
return(
.C(
"LGTr_C",
x,
nrow(x),
ncol(x),
method
)[[1L]]
)
}
#'
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chisq") -> chisq
LGTransforms(x,"profile") -> sp_pr
LGTransforms(x,"Hellinger") -> Helli
dist(chord)
dist(chisq)
dist(sp_pr)
dist(Helli)
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chord",lambda=0) -> log.chord
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chord",lambda=0) -> log.chord
LGTransforms(x,"chisq") -> chisq
LGTransforms(x,"profile") -> sp_pr
LGTransforms(x,"Hellinger") -> Helli
dist(chord)
dist(chisq)
dist(sp_pr)
dist(Helli)
dist(chord)
dist(log.chord)
dist(chisq)
dist(sp_pr)
dist(Helli)
data(LGDat)
as.matrix(dist(LGDat[,1L])) -> geo
geo[upper.tri(geo)] -> geo
## Raw Euclidean distances
par(mfrow=c(1,1), mar=c(5,5,4,2))
as.matrix(dist(LGDat[,-1L])) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo, data=data.frame(geo=geo, eco=eco),
xaxp=c(1,18,17), las=1, ylim=c(0,max(eco)),
xlab="True geographic distance",
ylab="Euclidean distance")
## Euclidean distances on the transformed abundances:
par(mfrow=c(2,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chisq") -> chisq
as.matrix(dist(chisq)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chi-square distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"profile") -> sp_pr
as.matrix(dist(sp_pr)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Dist. between profiles",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
as.matrix(dist(Helli)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Hellinger distance",ylim=c(0,max(eco)))
mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)
as.matrix(dist(LGDat[,1L])) -> geo
geo[upper.tri(geo)] -> geo
## Raw Euclidean distances
par(mfrow=c(1,1), mar=c(5,5,4,2))
as.matrix(dist(LGDat[,-1L])) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo, data=data.frame(geo=geo, eco=eco),
xaxp=c(1,18,17), las=1, ylim=c(0,max(eco)),
xlab="True geographic distance",
ylab="Euclidean distance")
## Transforming the abundances
LGTransforms(x,"chord") -> chord
LGTransforms(x,"chord",lambda=0) -> log.chord
LGTransforms(x,"chord",lambda=0.25,alpha=0) -> pow.chord
LGTransforms(x,"chisq") -> chisq
LGTransforms(x,"profile") -> sp_pr
LGTransforms(x,"Hellinger") -> Helli
dist(chord)
dist(log.chord)
dist(chord)
dist(log.chord)
dist(pow.chord)
dist(chord)
dist(log.chord)
dist(pow.chord)
dist(chisq)
dist(sp_pr)
dist(Helli)
data(LGDat)
as.matrix(dist(LGDat[,1L])) -> geo
geo[upper.tri(geo)] -> geo
## Raw Euclidean distances
par(mfrow=c(1,1), mar=c(5,5,4,2))
as.matrix(dist(LGDat[,-1L])) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo, data=data.frame(geo=geo, eco=eco),
xaxp=c(1,18,17), las=1, ylim=c(0,max(eco)),
xlab="True geographic distance",
ylab="Euclidean distance")
## Euclidean distances on the transformed abundances:
par(mfrow=c(2,2), mar=c(5,5,4,2))
## Euclidean distances on the transformed abundances:
par(mfrow=c(3,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
par(mfrow=c(3,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0.25,alpha=0) -> pow.chord
as.matrix(dist(chord)) -> eco
par(mfrow=c(3,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(log.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0.25,alpha=0) -> pow.chord
as.matrix(dist(pow.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chisq") -> chisq
as.matrix(dist(chisq)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chi-square distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"profile") -> sp_pr
as.matrix(dist(sp_pr)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Dist. between profiles",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
as.matrix(dist(Helli)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Hellinger distance",ylim=c(0,max(eco)))
mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)
par(mfrow=c(3,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(log.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (log(x+1))",ylim=c(0,max(eco)))
par(mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord",lambda=0.25,alpha=0) -> pow.chord
as.matrix(dist(pow.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (lambda=0.25)",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chisq") -> chisq
as.matrix(dist(chisq)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chi-square distance",ylim=c(0,max(eco)))
par(mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"profile") -> sp_pr
as.matrix(dist(sp_pr)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Dist. between profiles",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
as.matrix(dist(Helli)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Hellinger distance",ylim=c(0,max(eco)))
mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)
## Euclidean distances on the transformed abundances:
par(mfrow=c(3,2), mar=c(5,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
par(mfrow=c(3,2), mar=c(3,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(log.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (log(x+1))",ylim=c(0,max(eco)))
par(mar=c(4,5,3,2))
LGTransforms(LGDat[,-1L],"chord",lambda=0.25,alpha=0) -> pow.chord
as.matrix(dist(pow.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (lambda=0.25)",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chisq") -> chisq
as.matrix(dist(chisq)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chi-square distance",ylim=c(0,max(eco)))
par(mar=c(5,5,2,2))
LGTransforms(LGDat[,-1L],"profile") -> sp_pr
as.matrix(dist(sp_pr)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Dist. between profiles",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
as.matrix(dist(Helli)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Hellinger distance",ylim=c(0,max(eco)))
par(mfrow=c(3,2), mar=c(3,5,4,2))
LGTransforms(LGDat[,-1L],"chord") -> chord
as.matrix(dist(chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chord distance",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chord",lambda=0) -> log.chord
as.matrix(dist(log.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (log(x+1))",ylim=c(0,max(eco)))
par(mar=c(4,5,3,2))
LGTransforms(LGDat[,-1L],"chord",lambda=0.25) -> pow.chord
as.matrix(dist(pow.chord)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Box-Cox Chord distance (lambda=0.25)",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"chisq") -> chisq
as.matrix(dist(chisq)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Chi-square distance",ylim=c(0,max(eco)))
par(mar=c(5,5,2,2))
LGTransforms(LGDat[,-1L],"profile") -> sp_pr
as.matrix(dist(sp_pr)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Dist. between profiles",ylim=c(0,max(eco)))
LGTransforms(LGDat[,-1L],"Hellinger") -> Helli
as.matrix(dist(Helli)) -> eco
eco[upper.tri(eco)] -> eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
xaxp=c(1,18,17),las=1,xlab="",ylab="",
main="Hellinger distance",ylim=c(0,max(eco)))
mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)
library(codep)
##
rm(list=ls())
library(codep)
?LGTransforms
